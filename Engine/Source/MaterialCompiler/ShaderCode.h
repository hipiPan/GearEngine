#pragma once
namespace gear {
const char BRDF_FS_DATA[] = "float D_GGX(float roughness, float NoH) {\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    float d = k * k * (1.0 / PI);\n    return saturate(d);\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    float v = 0.5 / (GGXV + GGXL);\n    return saturate(v);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // f90 = 1.0\n    float f = pow(1.0 - VoH, 5.0);\n    return f + f0 * (1.0 - f);\n}\n\nfloat Distribution(float roughness, float NoH, const vec3 H) {\n    return D_GGX(roughness, NoH);\n}\n\nfloat Visibility(float roughness, float NoV, float NoL) {\n    return V_SmithGGXCorrelated(roughness, NoV, NoL);\n}\n\nvec3 Fresnel(const vec3 f0, float LoH) {\n    return F_Schlick(f0, LoH);\n}\n\nfloat Diffuse(float roughness, float NoV, float NoL, float LoH) {\n    // Todo: Burley Diffuse\n    return 1.0 / PI;\n}";
const char BRDF_INTEGRATION_COMP_DATA[] = "#version 450 core\n\n#define PI 3.14159265359\n#define SampleCount 1024\n\nlayout(binding = 2000, rg32f) uniform image2D dst_texture;\n\nlayout(push_constant) uniform ConstantBlock {\n	uint lut_size;\n} constant;\n\nlayout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n\nfloat RadicalInverse_VdC(uint bits) {\n	(bits = ((bits << uint (16)) | (bits >> uint (16))));\n	(bits = (((bits & 1431655765u) << uint (1)) | ((bits & 2863311530u) >> uint (1))));\n	(bits = (((bits & 858993459u) << uint (2)) | ((bits & 3435973836u) >> uint (2))));\n	(bits = (((bits & 252645135u) << uint (4)) | ((bits & 4042322160u) >> uint (4))));\n	(bits = (((bits & 16711935u) << uint (8)) | ((bits & 4278255360u) >> uint (8))));\n	return (float(bits) * 2.328306e-10);\n}\n\nvec2 Hammersley(uint i, uint N) {\n	return vec2((float(i) / float(N)), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n	float a = (roughness * roughness);\n\n	float phi = 2.0 * PI * Xi.x;\n	float cos_theta = sqrt((1.0 - Xi.y) / (1.0 + ((a * a - 1.0) * Xi.y)));\n	float sin_theta = sqrt(1.0 - (cos_theta * cos_theta));\n\n	vec3 H;\n	H.x = cos(phi) * sin_theta;\n	H.y = sin(phi) * sin_theta;\n	H.z = cos_theta;\n\n	vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n	vec3 tangent = normalize(cross(up, N));\n	vec3 bitangent = cross(N, tangent);\n\n	vec3 sample_vec = tangent * vec3(H.x) + bitangent * vec3(H.y) + N * vec3(H.z);\n	return normalize(sample_vec);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n	float a = roughness;\n	float k = (a * a) / 2.0;\n\n	float nom = NdotV;\n	float denom = NdotV * (1.0 - k) + k;\n\n	return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n	float NdotV = max(dot(N, V), 0.0);\n	float NdotL = max(dot(N, L), 0.0);\n	float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n	float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n	return ggx1 * ggx2;\n}\n\nvec2 IntegrateBRDF(float NdotV, float roughness) {\n	vec3 V;\n	V.x = sqrt(1.0 - NdotV * NdotV);\n	V.y = 0.0;\n	V.z = NdotV;\n\n	float A = 0.0;\n	float B = 0.0;\n\n	vec3 N = vec3(0.0, 0.0, 1.0);\n	for (int i = 0; i < SampleCount; ++i) {\n		vec2 Xi = Hammersley(i, SampleCount);\n		vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n		vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n		float NdotL = max(L.z, 0.0);\n		float NdotH = max(H.z, 0.0);\n		float VdotH = max(dot(V, H), 0.0);\n\n		if (NdotL > 0.0) {\n			float G = GeometrySmith(N, V, L, roughness);\n			float G_Vis = (G * VdotH) / (NdotH * NdotV);\n			float Fc = pow(1.0 - VdotH, 5.0);\n\n			A += (1.0 - Fc) * G_Vis;\n			B += Fc * G_Vis;\n		}\n	}\n\n	A /= float(SampleCount);\n	B /= float(SampleCount);\n\n	return vec2(A, B);\n}\n\nvoid main() {\n	vec2 texcoords = vec2(float(gl_GlobalInvocationID.x + 0.5) / constant.lut_size, 1.0 - float(gl_GlobalInvocationID.y + 0.5) / constant.lut_size);\n	imageStore(dst_texture, ivec2(gl_GlobalInvocationID), vec4(IntegrateBRDF(texcoords.x, texcoords.y), 0.0, 0.0));\n}";
const char COMMON_DATA_FS_DATA[] = "layout(std140, set = 0, binding = 1) uniform FrameUniforms {\n    mat4 view_matrix;\n    mat4 main_view_matrix;\n    mat4 proj_matrix;\n    mat4 sun_matrixs[SHADOW_CASCADE_COUNT];\n    vec4 sun_direction;\n    vec4 sun_color_intensity;\n    vec4 view_position;\n    vec4 cascade_splits;\n    float ev100;\n    float exposure;\n} frame_uniforms;\n\nlayout(std140, set = 0, binding = 2) uniform ObjectUniforms {\n    mat4 local_matrix;\n    mat4 model_matrix;\n    mat4 normal_matrix;\n} object_uniforms;\n\n#if defined(HAS_SKINNING_OR_MORPHING)\n#define MAX_NUM_JOINTS 64\n\nlayout(std140, set = 0, binding = 3) uniform BoneUniforms {\n    mat4 joint_matrixs[MAX_NUM_JOINTS];\n} bone_uniforms;\n\n#endif\n\n#if defined(HAS_SHADOWING)\nlayout(set = 0, binding = 1010) uniform texture2DArray cascade_shadow_map;\nlayout(set = 0, binding = 3010) uniform sampler cascade_shadow_sampler;\n#endif\n\n#if defined(HAS_IBL)\nlayout(set = 0, binding = 1011) uniform textureCube irradiance_map;\nlayout(set = 0, binding = 1012) uniform textureCube prefiltered_map;\nlayout(set = 0, binding = 1013) uniform texture2D brdf_lut;\nlayout(set = 0, binding = 3011) uniform sampler ibl_sampler;\n#endif\n\n#define PI                 3.14159265359\n\n#define HALF_PI            1.570796327\n\n#define saturate(x)        clamp(x, 0.0, 1.0)\n\n#define atan2(x, y)        atan(y, x)\n\nstruct Light {\n    vec4 color_intensity;\n    float attenuation;\n    vec3 world_position;\n    vec3 L;\n};\n\n// Global Params\nvec3 shading_view;\n\nvec3 shading_normal;";
const char COMPUTE_IRRADIANCE_MAP_COMP_DATA[] = "#version 450 core\n\n#define PI 3.14159265359\n#define SampleDelta 0.025\n\nlayout(binding = 1000) uniform textureCube src_texture;\nlayout(binding = 3000) uniform sampler src_sampler;\nlayout(binding = 2000, rgba32f) uniform image2DArray dst_texture;\n\nlayout(push_constant) uniform ConstantBlock {\n	uint mip_level;\n	uint max_size;\n} constant;\n\nlayout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n\nvec4 ComputeIrradiance(vec3 N) {\n    vec4 irradiance = vec4(0.0);\n\n    vec3 up = vec3(0.000000, 1.000000, 0.000000);\n    vec3 right = cross(up, N);\n    up = cross(N, right);\n\n    float num_samples = 0.0;\n\n    for (float phi = 0.0; phi < 2.0 * PI; phi += SampleDelta) {\n        for (float theta = 0.0; theta < 0.5 * PI; theta += SampleDelta) {\n            vec3 tangent_sample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n\n            vec3 sample_vec = vec3(tangent_sample.x) * right + vec3(tangent_sample.y) * up + vec3(tangent_sample.z) * N;\n\n            vec4 sampled_value = textureLod(samplerCube(src_texture, src_sampler), sample_vec, 0.0);\n\n            irradiance += vec4(sampled_value.rgb * vec3(cos(theta)) * vec3(sin(theta)), sampled_value.a);\n            num_samples++;\n        }\n    }\n\n    return PI * irradiance * vec4(1.0 / num_samples);\n}\n\nvoid main() {\n    uint mip_level = constant.mip_level;\n    float mip_size = float(constant.max_size >> mip_level);\n\n    vec3 thread_pos = vec3(gl_GlobalInvocationID);\n    vec2 texcoords = vec2((thread_pos.x + 0.5) / mip_size, (thread_pos.y + 0.5) / mip_size);\n    texcoords = (texcoords * 2.0) - 1.0;\n\n    vec3 sphere_dir;\n    // +x\n	if (thread_pos.z <= 0.0) {\n		sphere_dir = normalize(vec3(1.0, -texcoords.y, -texcoords.x));\n    }\n    // -x\n	else if (thread_pos.z <= 1.0) {\n        sphere_dir = normalize(vec3(-1.0, -texcoords.y, texcoords.x));\n    }\n    // +y\n    else if (thread_pos.z <= 2.0) {\n        sphere_dir = normalize(vec3(texcoords.x, 1.0, texcoords.y));\n    }\n    // -y\n    else if (thread_pos.z <= 3.0) {\n        sphere_dir = normalize(vec3(texcoords.x, -1.0, -texcoords.y));\n    }\n    // +z\n    else if (thread_pos.z <= 4.0) {\n        sphere_dir = normalize(vec3(texcoords.x, -texcoords.y, 1.0));\n    }\n    // -z\n    else if (thread_pos.z <= 5.0) {\n        sphere_dir = normalize(vec3(-texcoords.x, -texcoords.y, -1.0));\n    }\n\n    vec4 irradiance = ComputeIrradiance(sphere_dir);\n\n    imageStore(dst_texture, ivec3(ivec3(thread_pos)), irradiance);\n}";
const char COMPUTE_SPECULAR_MAP_COMP_DATA[] = "#version 450 core\n\n#define PI 3.14159265359\n#define SampleCount 1024\n\nlayout(binding = 1000) uniform textureCube src_texture;\nlayout(binding = 3000) uniform sampler src_sampler;\nlayout(binding = 2000, rgba32f) uniform image2DArray dst_texture;\n\nlayout(push_constant) uniform ConstantBlock {\n    uint mip_level;\n	uint max_size;\n	float roughness;\n} constant;\n\nlayout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n\nfloat RadicalInverse_VdC(uint bits) {\n	(bits = ((bits << uint (16)) | (bits >> uint (16))));\n	(bits = (((bits & 1431655765u) << uint (1)) | ((bits & 2863311530u) >> uint (1))));\n	(bits = (((bits & 858993459u) << uint (2)) | ((bits & 3435973836u) >> uint (2))));\n	(bits = (((bits & 252645135u) << uint (4)) | ((bits & 4042322160u) >> uint (4))));\n	(bits = (((bits & 16711935u) << uint (8)) | ((bits & 4278255360u) >> uint (8))));\n	return (float(bits) * 2.328306e-10);\n}\n\nvec2 Hammersley(uint i, uint N) {\n	return vec2((float(i) / float(N)), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n	float a = (roughness * roughness);\n\n	float phi = 2.0 * PI * Xi.x;\n	float cos_theta = sqrt((1.0 - Xi.y) / (1.0 + ((a * a - 1.0) * Xi.y)));\n	float sin_theta = sqrt(1.0 - (cos_theta * cos_theta));\n\n	vec3 H;\n	H.x = cos(phi) * sin_theta;\n	H.y = sin(phi) * sin_theta;\n	H.z = cos_theta;\n\n	vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n	vec3 tangent = normalize(cross(up, N));\n	vec3 bitangent = cross(N, tangent);\n\n	vec3 sample_vec = tangent * vec3(H.x) + bitangent * vec3(H.y) + N * vec3(H.z);\n	return normalize(sample_vec);\n}\n\nvoid main() {\n	uint mip_level = constant.mip_level;\n	float mip_size = float(constant.max_size >> mip_level);\n	float roughness = constant.roughness;\n\n	vec3 thread_pos = vec3(gl_GlobalInvocationID);\n	vec2 texcoords = vec2((thread_pos.x + 0.5) / mip_size, (thread_pos.y + 0.5) / mip_size);\n	texcoords = (texcoords * 2.0) - 1.0;\n\n	vec3 sphere_dir;\n	// +x\n	if (thread_pos.z <= 0.0) {\n		sphere_dir = normalize(vec3(1.0, -texcoords.y, -texcoords.x));\n	}\n	// -x\n	else if (thread_pos.z <= 1.0) {\n		sphere_dir = normalize(vec3(-1.0, -texcoords.y, texcoords.x));\n	}\n	// +y\n	else if (thread_pos.z <= 2.0) {\n		sphere_dir = normalize(vec3(texcoords.x, 1.0, texcoords.y));\n	}\n	// -y\n	else if (thread_pos.z <= 3.0) {\n		sphere_dir = normalize(vec3(texcoords.x, -1.0, -texcoords.y));\n	}\n	// +z\n	else if (thread_pos.z <= 4.0) {\n		sphere_dir = normalize(vec3(texcoords.x, -texcoords.y, 1.0));\n	}\n	// -z\n	else if (thread_pos.z <= 5.0) {\n		sphere_dir = normalize(vec3(-texcoords.x, -texcoords.y, -1.0));\n	}\n\n	vec3 N = sphere_dir;\n	vec3 R = N;\n	vec3 V = R;\n\n	float total_weight = 0.0;\n	vec4 prefiltered_color = vec4(0.0, 0.0, 0.0, 0.0);\n\n	for (int i = 0; i < SampleCount; ++i) {\n		vec2 Xi = Hammersley(uint(i), uint(SampleCount));\n		vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n		vec3 L = normalize((vec3(2.0 * dot(V, H)) * H) - V);\n\n		float NdotL = max(dot(N, L), 0.0);\n		if (NdotL > 0.0) {\n			prefiltered_color += textureLod(samplerCube(src_texture, src_sampler), vec3(L), 0.0) * NdotL;\n\n			total_weight += NdotL;\n		}\n	}\n\n	prefiltered_color = prefiltered_color / total_weight;\n	imageStore(dst_texture, ivec3(thread_pos), prefiltered_color);\n}";
const char DEPTH_MAIN_FS_DATA[] = "void main() {\n}\n";
const char DEPTH_MAIN_VS_DATA[] = "void main() {\n    MaterialVertexParams material_params;\n\n    InitMaterialVertexParams(material_params);\n\n    ProcessMaterialVertexParams(material_params);\n\n    vec4 world_position = material_params.world_position;\n#if defined(HAS_SKINNING_OR_MORPHING) && defined(HAS_ATTRIBUTE_BONE_INDICES)\n    mat4 skin_matrix = \n		mesh_bone_weights.x * bone_uniforms.joint_matrixs[int(mesh_bone_indices.x)] +\n		mesh_bone_weights.y * bone_uniforms.joint_matrixs[int(mesh_bone_indices.y)] +\n		mesh_bone_weights.z * bone_uniforms.joint_matrixs[int(mesh_bone_indices.z)] +\n		mesh_bone_weights.w * bone_uniforms.joint_matrixs[int(mesh_bone_indices.w)];\n    \n    world_position = object_uniforms.model_matrix * skin_matrix * mesh_position;\n#endif\n\n    gl_Position = frame_uniforms.proj_matrix * frame_uniforms.view_matrix * world_position;\n}\n";
const char INPUTS_FS_DATA[] = "layout(location = 0) in highp vec3 vertex_world_position;\n\n#if defined(HAS_ATTRIBUTE_UV0) && !defined(HAS_ATTRIBUTE_UV1)\nlayout(location = 5) in highp vec2 vertex_uv01;\n#elif defined(HAS_ATTRIBUTE_UV1)\nlayout(location = 5) in highp vec4 vertex_uv01;\n#endif\n\n#if defined(HAS_ATTRIBUTE_NORMAL)\nlayout(location = 6) in highp vec3 vertex_normal;\n#endif\n\n#if defined(HAS_ATTRIBUTE_COLOR)\nlayout(location = 7) in mediump vec4 vertex_color;\n#endif";
const char INPUTS_VS_DATA[] = "layout(location = LOCATION_POSITION) in vec4 mesh_position;\n\n#if defined(HAS_ATTRIBUTE_NORMAL)\nlayout(location = LOCATION_NORMAL) in vec3 mesh_normal;\nlayout(location = LOCATION_TANGENT) in vec3 mesh_tangent;\nlayout(location = LOCATION_BITANGENT) in vec3 mesh_bitangent;\n#endif\n\n#if defined(HAS_ATTRIBUTE_COLOR)\nlayout(location = LOCATION_COLOR) in vec4 mesh_color;\n#endif\n\n#if defined(HAS_ATTRIBUTE_UV0)\nlayout(location = LOCATION_UV0) in vec2 mesh_uv0;\n#endif\n\n#if defined(HAS_ATTRIBUTE_UV1)\nlayout(location = LOCATION_UV1) in vec2 mesh_uv1;\n#endif\n\n#if defined(HAS_ATTRIBUTE_BONE_INDICES)\nlayout(location = LOCATION_BONE_INDICES) in uvec4 mesh_bone_indices;\nlayout(location = LOCATION_BONE_WEIGHTS) in vec4 mesh_bone_weights;\n#endif\n\n\n#if defined(HAS_ATTRIBUTE_CUSTOM0)\nlayout(location = LOCATION_CUSTOM0) in vec4 mesh_custom0;\n#endif\n\n#if defined(HAS_ATTRIBUTE_CUSTOM1)\nlayout(location = LOCATION_CUSTOM1) in vec4 mesh_custom1;\n#endif\n\n#if defined(HAS_ATTRIBUTE_CUSTOM2)\nlayout(location = LOCATION_CUSTOM2) in vec4 mesh_custom2;\n#endif\n\n#if defined(HAS_ATTRIBUTE_CUSTOM3)\nlayout(location = LOCATION_CUSTOM3) in vec4 mesh_custom3;\n#endif\n\n#if defined(HAS_ATTRIBUTE_CUSTOM4)\nlayout(location = LOCATION_CUSTOM4) in vec4 mesh_custom4;\n#endif\n\n#if defined(HAS_ATTRIBUTE_CUSTOM5)\nlayout(location = LOCATION_CUSTOM5) in vec4 mesh_custom5;\n#endif\n\nlayout(location = 0) out highp vec3 vertex_world_position;\n\nlayout(location = 1) out highp vec4 vertex_position;\n\n#if defined(HAS_ATTRIBUTE_UV0) && !defined(HAS_ATTRIBUTE_UV1)\nlayout(location = 5) out highp vec2 vertex_uv01;\n#elif defined(HAS_ATTRIBUTE_UV1)\nlayout(location = 5) out highp vec4 vertex_uv01;\n#endif\n\n#if defined(HAS_ATTRIBUTE_NORMAL)\nlayout(location = 6) out highp vec3 vertex_normal;\n#endif\n\n#if defined(HAS_ATTRIBUTE_COLOR)\nlayout(location = 7) out mediump vec4 vertex_color;\n#endif\n";
const char LIGHT_DIRECTIONAL_FS_DATA[] = "#if defined(HAS_SHADOWING)\n\nfloat SampleCascadeShadowMap(const uint cascade, vec2 base, vec2 dudv, float depth, float bias) {\n    return depth - bias > texture(sampler2DArray(cascade_shadow_map, cascade_shadow_sampler), vec3(base + dudv, cascade)).r ? 0.5 : 0.0;\n}\n\nfloat SampleCascadeShadowMapWithPCF() {\n    vec3 view_position = (frame_uniforms.main_view_matrix * vec4(vertex_world_position, 1.0)).xyz;\n    bvec3 greater_z = greaterThan(vec3(abs(view_position.z)), frame_uniforms.cascade_splits.xyz);\n    uint cascade = clamp(uint(dot(vec3(greater_z), vec3(1.0))), 0u, SHADOW_CASCADE_COUNT - 1u);\n\n    vec4 light_space_position = (frame_uniforms.sun_matrixs[cascade] * vec4(vertex_world_position, 1.0));\n    vec3 proj_coords = light_space_position.xyz / light_space_position.w;\n    proj_coords.xy = proj_coords.xy * 0.5 + 0.5;\n\n    vec2 size = vec2(textureSize(sampler2DArray(cascade_shadow_map, cascade_shadow_sampler), 0));\n    vec2 texel_size = vec2(1.0) / size;\n\n	vec2 uv = proj_coords.xy;\n    float depth = proj_coords.z;\n\n    float bias = 0.01;\n#if defined(HAS_ATTRIBUTE_NORMAL)\n    bias = max(0.06 * (1.0 - dot(normalize(vertex_normal), normalize(-frame_uniforms.sun_direction.xyz))), 0.01);\n#endif\n\n    float sum = 0.0;\n\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(0.0, 0.0), depth, bias);\n\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(texel_size.x, 0.0), depth, bias);\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(-texel_size.x, 0.0), depth, bias);\n\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(0.0, texel_size.y), depth, bias);\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(0.0, -texel_size.y), depth, bias);\n\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(texel_size.x, texel_size.y), depth, bias);\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(texel_size.x, -texel_size.y), depth, bias);\n\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(-texel_size.x, texel_size.y), depth, bias);\n    sum += SampleCascadeShadowMap(cascade, uv, vec2(-texel_size.x, -texel_size.y), depth, bias);\n\n    return sum * (1.0 / 9.0);\n}\n#endif\n\nvoid EvaluateDirectionalLight(const MaterialFragmentParams material_params, inout vec3 color) {\n#if !defined(HAS_ATTRIBUTE_NORMAL)\n    return;\n#endif\n\n    float visibility = 1.0;\n#if defined(HAS_SHADOWING)\n    visibility = SampleCascadeShadowMapWithPCF();\n#endif\n\n    Light light;\n    light.color_intensity.rgb = frame_uniforms.sun_color_intensity.rgb;\n    light.color_intensity.w = frame_uniforms.sun_color_intensity.w * frame_uniforms.exposure;\n    light.attenuation = 1.0;\n    light.L = -frame_uniforms.sun_direction.xyz;\n\n    color.rgb += SurfaceShading(material_params, light, visibility);\n}";
const char LIGHT_INDIRECT_FS_DATA[] = "vec3 FresnelSchlickRoughness(float cos_theta, vec3 F0, float roughness) {\n	return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cos_theta, 5.0);\n}\n\n#if defined(HAS_IBL)\nvoid EvaluateIBL(const MaterialFragmentParams material_params, inout vec3 color) {\n#if defined(HAS_ATTRIBUTE_NORMAL)\n    // Todo: Flexible f0\n    vec3 F0 = vec3(material_params.metallic);\n    vec3 N = normalize(vertex_normal);\n	vec3 V = normalize(frame_uniforms.view_position.xyz - vertex_world_position);\n	vec3 R = reflect(-V, N);\n	vec3 F = FresnelSchlickRoughness(max(dot(N, V), 0.0), F0, material_params.roughness);\n	vec3 kS = F;\n	vec3 kD = vec3(1.0) - kS;\n	kD *= 1.0 - material_params.metallic;\n\n	vec3 irradiance = texture(samplerCube(irradiance_map, ibl_sampler), N).rgb;\n	vec3 diffuse = kD * irradiance * material_params.base_color.rgb;\n\n	vec3 prefiltered_color = textureLod(samplerCube(prefiltered_map, ibl_sampler), R, uint(material_params.roughness * 4)).rgb;\n	vec2 brdf = texture(sampler2D(brdf_lut, ibl_sampler), vec2(max(dot(N, V), 0.0), material_params.roughness)).rg;\n	vec3 specular = prefiltered_color * (F * brdf.x + brdf.y);\n	vec3 ambient = diffuse + specular;\n	\n	color += ambient * 0.3;\n#endif\n}\n#endif";
const char LIGHT_PUNCTUAL_FS_DATA[] = "void EvaluatePunctualLights(const MaterialFragmentParams material_params, inout vec3 color) {\n    \n}";
const char MAIN_FS_DATA[] = "layout(location = 0) out vec4 fragColor;\n\nvoid PrepareShadingParams() {\n    shading_view = normalize(frame_uniforms.view_position.xyz - vertex_world_position);\n\n    #if defined(HAS_ATTRIBUTE_NORMAL)\n    shading_normal = vertex_normal;\n    #endif\n}\n\nvoid main() {\n    PrepareShadingParams();\n\n    MaterialFragmentParams material_params;\n\n    InitMaterialFragmentParams(material_params);\n\n    ProcessMaterialFragmentParams(material_params);\n    \n    fragColor = EvaluateMaterial(material_params);\n}\n";
const char MAIN_VS_DATA[] = "void main() {\n    MaterialVertexParams material_params;\n\n    InitMaterialVertexParams(material_params);\n\n    ProcessMaterialVertexParams(material_params);\n\n    vec4 world_position = material_params.world_position;\n#if defined(HAS_SKINNING_OR_MORPHING) && defined(HAS_ATTRIBUTE_BONE_INDICES)\n    mat4 skin_matrix = \n		mesh_bone_weights.x * bone_uniforms.joint_matrixs[int(mesh_bone_indices.x)] +\n		mesh_bone_weights.y * bone_uniforms.joint_matrixs[int(mesh_bone_indices.y)] +\n		mesh_bone_weights.z * bone_uniforms.joint_matrixs[int(mesh_bone_indices.z)] +\n		mesh_bone_weights.w * bone_uniforms.joint_matrixs[int(mesh_bone_indices.w)];\n    \n    world_position = object_uniforms.model_matrix * skin_matrix * mesh_position;\n#endif\n\n    vertex_position = frame_uniforms.view_matrix * world_position;\n\n    vertex_world_position = world_position.xyz;\n\n#if defined(HAS_ATTRIBUTE_UV0)\n    vertex_uv01.xy = material_params.uv0;\n#endif\n#if defined(HAS_ATTRIBUTE_UV1)\n    vertex_uv01.zw = material_params.uv1;\n#endif\n\n#if defined(HAS_ATTRIBUTE_COLOR)\n    vertex_color = material_params.color;\n#endif\n\n#if defined(HAS_ATTRIBUTE_NORMAL)\n    vertex_normal = material_params.world_normal;\n#endif\n\n    gl_Position = frame_uniforms.proj_matrix * frame_uniforms.view_matrix * world_position;\n}\n";
const char MATERIAL_PARAMS_FS_DATA[] = "struct MaterialFragmentParams {\n    vec4 base_color;\n    vec3 specular_color;\n    float roughness;\n    float metallic;\n};\n\nvoid InitMaterialFragmentParams(out MaterialFragmentParams params) {\n    params.base_color = vec4(1.0);\n    params.roughness = 0.5;\n    params.metallic = 0.5;\n}";
const char MATERIAL_PARAMS_VS_DATA[] = "struct MaterialVertexParams {\n    vec4 world_position;\n\n#ifdef HAS_ATTRIBUTE_NORMAL\n    vec3 world_normal;\n#endif\n\n#ifdef HAS_ATTRIBUTE_COLOR\n    vec4 color;\n#endif\n\n#ifdef HAS_ATTRIBUTE_UV0\n    vec2 uv0;\n#endif\n\n#ifdef HAS_ATTRIBUTE_UV1\n    vec2 uv1;\n#endif\n};\n\nvoid InitMaterialVertexParams(out MaterialVertexParams params) {\n    params.world_position = object_uniforms.model_matrix * mesh_position;\n\n#ifdef HAS_ATTRIBUTE_COLOR\n    params.color = mesh_color;\n#endif\n\n#ifdef HAS_ATTRIBUTE_UV0\n    params.uv0 = mesh_uv0;\n#endif\n\n#ifdef HAS_ATTRIBUTE_UV1\n    params.uv1 = mesh_uv1;\n#endif\n\n#ifdef HAS_ATTRIBUTE_NORMAL\n    params.world_normal = normalize(mat3(object_uniforms.normal_matrix) * mesh_normal);\n#endif\n}\n";
const char PANO_TO_CUBE_COMP_DATA[] = "#version 450\n#extension GL_ARB_separate_shader_objects : enable\n\nlayout(binding = 1000) uniform texture2D src_texture;\nlayout(binding = 3000) uniform sampler src_sampler;\nlayout(binding = 2000, rgba32f) uniform image2DArray dst_texture;\n\nlayout(push_constant) uniform ConstantBlock {\n	uint mip_level;\n	uint max_size;\n} constant;\n\n\nlayout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n\nvoid main() {\n    vec3 thread_pos = vec3(gl_GlobalInvocationID);\n    float PI = 3.14159274;\n	vec2 inv_atan = vec2(0.1591, 0.31830000);\n	uint mip_level = constant.mip_level;\n	float mip_size = float(constant.max_size >> mip_level);\n\n	if ((thread_pos.x >= mip_size) || (thread_pos.y >= mip_size)) \n		return;\n\n	vec2 texcoords = vec2(((thread_pos.x + 0.5) / mip_size), ((thread_pos.y + 0.5) / mip_size));\n    texcoords = (texcoords * 2.0) - 1.0;\n\n	vec3 sphere_dir;\n    // +x\n	if (thread_pos.z <= 0.0) {\n		sphere_dir = normalize(vec3(1.0, texcoords.y, -texcoords.x));\n    }\n    // -x\n	else if (thread_pos.z <= 1.0) {\n        sphere_dir = normalize(vec3(-1.0, texcoords.y, texcoords.x));\n    }\n    // +y\n    else if (thread_pos.z <= 2.0) {\n        sphere_dir = normalize(vec3(texcoords.x, -1.0, texcoords.y));\n    }\n    // -y\n    else if (thread_pos.z <= 3.0) {\n        sphere_dir = normalize(vec3(texcoords.x, 1.0, -texcoords.y));\n    }\n    // +z\n    else if (thread_pos.z <= 4.0) {\n        sphere_dir = normalize(vec3(texcoords.x, texcoords.y, 1.0));\n    }\n    // -z\n    else if (thread_pos.z <= 5.0) {\n        sphere_dir = normalize(vec3(-texcoords.x, texcoords.y, -1.0));\n    }\n\n	vec2 pano_uvs = vec2(atan(sphere_dir.z, sphere_dir.x), asin(sphere_dir.y));\n	pano_uvs *= inv_atan;\n	pano_uvs += vec2(0.5);\n\n	imageStore(dst_texture, ivec3(uvec3(thread_pos.x, thread_pos.y, thread_pos.z)), texture(sampler2D(src_texture, src_sampler), vec2(pano_uvs)));\n}";
const char SHADING_LIT_FS_DATA[] = "vec4 EvaluateLights(const MaterialFragmentParams material_params) {\n    vec3 color = vec3(0.0);\n\n#if defined(HAS_DIRECTIONAL_LIGHTING)\n    EvaluateDirectionalLight(material_params, color);\n#endif\n\n#if defined(HAS_DYNAMIC_LIGHTING)\n    EvaluatePunctualLights(material_params, color);\n#endif\n\n#if defined(HAS_IBL)\n    EvaluateIBL(material_params, color);\n#endif\n\n    return vec4(color, material_params.base_color.a);\n}\n\nvec4 EvaluateMaterial(const MaterialFragmentParams material_params) {\n    vec4 color = EvaluateLights(material_params);\n    return color;\n}";
const char SHADING_MODEL_STANDARD_FS_DATA[] = "\nvec3 SpecularLobe(const MaterialFragmentParams params, vec3 H, float NoV, float NoL, float NoH, float LoH) {\n    // Todo: Flexible f0\n    float D = Distribution(params.roughness, NoH, H);\n    float G = Visibility(params.roughness, NoV, NoL);\n    vec3  F = Fresnel(vec3(params.metallic), LoH);\n    return (D * G * F) / (4.0 * max(NoV, 0.0) * max(NoL, 0.0) + 0.001);\n}\n\nvec3 DiffuseLobe(const MaterialFragmentParams params, float NoV, float NoL, float LoH) {\n    vec3 diffuse_color = params.base_color.rgb * (1.0 - params.metallic);\n    return diffuse_color * Diffuse(params.roughness, NoV, NoL, LoH);\n}\n\nvec3 SurfaceShading(const MaterialFragmentParams params, const Light light, float visibility) {\n    vec3 H = normalize(shading_view + light.L);\n    float NoV = saturate(dot(shading_normal, shading_view));\n    float NoL = saturate(dot(shading_normal, light.L));\n    float NoH = saturate(dot(shading_normal, H));\n    float LoH = saturate(dot(light.L, H));\n\n    vec3 Fr = SpecularLobe(params, H, NoV, NoL, NoH, LoH);\n    vec3 Fd = DiffuseLobe(params, NoV, NoL, LoH);\n\n    vec3 color = Fd + Fr;\n\n    return color * light.color_intensity.rgb * light.color_intensity.w * light.attenuation * NoL * (1.0 - visibility);\n}";
const char SHADING_UNLIT_FS_DATA[] = "vec4 EvaluateMaterial(const MaterialFragmentParams material_params) {\n    vec4 color = material_params.base_color;\n    return color;\n}";
const char ATMOSPHERE_COMON_VS_DATA[] = "#version 450\n#extension GL_ARB_separate_shader_objects : enable\n\nlayout(location = 0) in vec2 vertex;\n\nvoid main() {\n    gl_Position = vec4(vertex, 0.0, 1.0);\n    gl_Position.y = -gl_Position.y;\n}\n";
const char ATMOSPHERE_COMPUTE_MULTI_SCATTERING_COMP_DATA[] = "#version 450\n#extension GL_ARB_separate_shader_objects : enable\n\nuint TRANSMITTANCE_TEXTURE_WIDTH = 64;\nuint TRANSMITTANCE_TEXTURE_HEIGHT = 16;\n\nuint MULTI_SCATTERING_TEXTURE_SIZE = 32;\n\n#define PI 3.1415926535897932384626433832795\n\n#define saturate(x)        clamp(x, 0.0, 1.0)\n\nlayout(std140, set = 0, binding = 0) uniform AtmosphereCB {\n    mat4 sky_inv_view_proj_mat;\n    vec4 resolution;\n    vec4 rayleigh_scattering;\n    vec4 mie_scattering;\n    vec4 mie_extinction;\n    vec4 mie_absorption;\n    vec4 absorption_extinction;\n    vec4 ground_albedo;\n    vec4 sun_direction;\n    vec4 view_direction;\n    vec4 view_position;\n    float bottom_radius;\n    float top_radius;\n    float rayleigh_density_exp_scale;\n    float mie_density_exp_scale;\n    float mie_phase_g;\n    float absorption_density0_layer_width;\n    float absorption_density0_constant_term;\n    float absorption_density0_linear_term;\n    float absorption_density1_constant_term;\n    float absorption_density1_linear_term;\n} atmosphere_cb;\n\nstruct AtmosphereParameters {\n    float bottom_radius;\n    float top_radius;\n\n    float rayleigh_density_exp_scale;\n    vec3 rayleigh_scattering;\n\n    float mie_density_exp_scale;\n    vec3 mie_scattering;\n    vec3 mie_extinction;\n    vec3 mie_absorption;\n    float mie_phase_g;\n\n    float absorption_density0_layer_width;\n    float absorption_density0_constant_term;\n    float absorption_density0_linear_term;\n    float absorption_density1_constant_term;\n    float absorption_density1_linear_term;\n    vec3 absorption_extinction;\n\n    vec3 ground_albedo;\n\n    vec3 sun_direction;\n    vec3 view_direction;\n    vec3 view_position;\n\n    vec2 resolution;\n    mat4 sky_inv_view_proj_mat;\n};\n\nAtmosphereParameters GetAtmosphereParameters()\n{\n    AtmosphereParameters atmosphere_parameters;\n    atmosphere_parameters.bottom_radius = atmosphere_cb.bottom_radius;\n    atmosphere_parameters.top_radius = atmosphere_cb.top_radius;\n\n    atmosphere_parameters.rayleigh_density_exp_scale = atmosphere_cb.rayleigh_density_exp_scale;\n    atmosphere_parameters.rayleigh_scattering = atmosphere_cb.rayleigh_scattering.xyz;\n\n    atmosphere_parameters.mie_density_exp_scale = atmosphere_cb.mie_density_exp_scale;\n    atmosphere_parameters.mie_scattering = atmosphere_cb.mie_scattering.xyz;\n    atmosphere_parameters.mie_extinction = atmosphere_cb.mie_extinction.xyz;\n    atmosphere_parameters.mie_absorption = atmosphere_cb.mie_absorption.xyz;\n    atmosphere_parameters.mie_phase_g = atmosphere_cb.mie_phase_g;\n\n    atmosphere_parameters.absorption_density0_layer_width = atmosphere_cb.absorption_density0_layer_width;\n    atmosphere_parameters.absorption_density0_constant_term = atmosphere_cb.absorption_density0_constant_term;\n    atmosphere_parameters.absorption_density0_linear_term = atmosphere_cb.absorption_density0_linear_term;\n    atmosphere_parameters.absorption_density1_constant_term = atmosphere_cb.absorption_density1_constant_term;\n    atmosphere_parameters.absorption_density1_linear_term = atmosphere_cb.absorption_density1_linear_term;\n    atmosphere_parameters.absorption_extinction = atmosphere_cb.absorption_extinction.xyz;\n\n    atmosphere_parameters.ground_albedo = atmosphere_cb.ground_albedo.xyz;\n\n    atmosphere_parameters.sun_direction = atmosphere_cb.sun_direction.xyz;\n    atmosphere_parameters.view_direction = atmosphere_cb.view_direction.xyz;\n    atmosphere_parameters.view_position = atmosphere_cb.view_position.xyz;\n\n    atmosphere_parameters.resolution = atmosphere_cb.resolution.xy;\n    atmosphere_parameters.sky_inv_view_proj_mat = atmosphere_cb.sky_inv_view_proj_mat;\n\n    return atmosphere_parameters;\n}\n\nfloat RaySphereIntersectNearest(vec3 r0, vec3 rd, vec3 s0, float sr)\n{\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float delta = b * b - 4.0*a*c;\n    if (delta < 0.0 || a == 0.0)\n    {\n        return -1.0;\n    }\n    float sol0 = (-b - sqrt(delta)) / (2.0*a);\n    float sol1 = (-b + sqrt(delta)) / (2.0*a);\n    if (sol0 < 0.0 && sol1 < 0.0)\n    {\n        return -1.0;\n    }\n    if (sol0 < 0.0)\n    {\n        return max(0.0, sol1);\n    }\n    else if (sol1 < 0.0)\n    {\n        return max(0.0, sol0);\n    }\n    return max(0.0, min(sol0, sol1));\n}\n\nstruct MediumSampleResult\n{\n    vec3 scattering;\n    vec3 absorption;\n    vec3 extinction;\n\n    vec3 scattering_mie;\n    vec3 absorption_mie;\n    vec3 extinction_mie;\n\n    vec3 scattering_ray;\n    vec3 absorption_ray;\n    vec3 extinction_ray;\n\n    vec3 scattering_ozo;\n    vec3 absorption_ozo;\n    vec3 extinction_ozo;\n\n    vec3 albedo;\n};\n\nvec3 GetAlbedo(vec3 scattering, vec3 extinction)\n{\n    return scattering / max(vec3(0.001), extinction);\n}\n\nMediumSampleResult SampleMedium(in vec3 world_pos, in AtmosphereParameters atmosphere)\n{\n    float view_height = length(world_pos) - atmosphere.bottom_radius;\n\n    float density_mie = exp(atmosphere.mie_density_exp_scale * view_height);\n    float density_ray = exp(atmosphere.rayleigh_density_exp_scale * view_height);\n    float density_ozo = saturate(view_height < atmosphere.absorption_density0_layer_width ?\n    atmosphere.absorption_density0_linear_term * view_height + atmosphere.absorption_density0_constant_term :\n    atmosphere.absorption_density1_linear_term * view_height + atmosphere.absorption_density1_constant_term);\n\n    MediumSampleResult s;\n\n    s.scattering_mie = density_mie * atmosphere.mie_scattering;\n    s.absorption_mie = density_mie * atmosphere.mie_absorption;\n    s.extinction_mie = density_mie * atmosphere.mie_extinction;\n\n    s.scattering_ray = density_ray * atmosphere.rayleigh_scattering;\n    s.absorption_ray = vec3(0.0);\n    s.extinction_ray = s.scattering_ray + s.absorption_ray;\n\n    s.scattering_ozo = vec3(0.0);\n    s.absorption_ozo = density_ozo * atmosphere.absorption_extinction;\n    s.extinction_ozo = s.scattering_ozo + s.absorption_ozo;\n\n    s.scattering = s.scattering_mie + s.scattering_ray + s.scattering_ozo;\n    s.absorption = s.absorption_mie + s.absorption_ray + s.absorption_ozo;\n    s.extinction = s.extinction_mie + s.extinction_ray + s.extinction_ozo;\n    s.albedo = GetAlbedo(s.scattering, s.extinction);\n\n    return s;\n}\n\nfloat RayleighPhase(float cos_theta)\n{\n	float factor = 3.0 / (16.0 * PI);\n	return factor * (1.0 + cos_theta * cos_theta);\n}\n\nfloat MiePhase(float g, float cos_theta)\n{\n	float numer = 1.0f - g * g;\n	float denom = 1.0f + g * g + 2.0f * g * cos_theta;\n	return numer / (4.0 * PI * denom * sqrt(denom));\n}\n\nfloat FromUnitToSubUvs(float u, float resolution) { return (u + 0.5 / resolution) * (resolution / (resolution + 1.0)); }\nfloat FromSubUvsToUnit(float u, float resolution) { return (u - 0.5 / resolution) * (resolution / (resolution - 1.0)); }\n\nvoid UvToLutTransmittanceParams(AtmosphereParameters atmosphere, out float view_height, out float view_zenith_cos_angle, in vec2 uv)\n{\n    float x_mu = uv.x;\n    float x_r = uv.y;\n\n    float H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);\n    float rho = H * x_r;\n    view_height = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);\n\n    float d_min = atmosphere.top_radius - view_height;\n    float d_max = rho + H;\n    float d = d_min + x_mu * (d_max - d_min);\n    view_zenith_cos_angle = d == 0.0 ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * view_height * d);\n    view_zenith_cos_angle = clamp(view_zenith_cos_angle, -1.0, 1.0);\n}\n\nvoid LutTransmittanceParamsToUv(AtmosphereParameters atmosphere, in float view_height, in float view_zenith_cos_angle, out vec2 uv)\n{\n	float H = sqrt(max(0.0, atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius));\n	float rho = sqrt(max(0.0, view_height * view_height - atmosphere.bottom_radius * atmosphere.bottom_radius));\n\n	float discriminant = view_height * view_height * (view_zenith_cos_angle * view_zenith_cos_angle - 1.0) + atmosphere.top_radius * atmosphere.top_radius;\n	float d = max(0.0, (-view_height * view_zenith_cos_angle + sqrt(discriminant)));\n\n	float d_min = atmosphere.top_radius - view_height;\n	float d_max = rho + H;\n	float x_mu = (d - d_min) / (d_max - d_min);\n	float x_r = rho / H;\n\n	uv = vec2(x_mu, x_r);\n}\n\nvec3 GetSunLuminance(vec3 world_pos, vec3 world_dir, vec3 sun_dir, float planet_radius) {\n	if (dot(world_dir, sun_dir) > cos(0.5 * 0.505 * 3.14159 / 180.0))\n	{\n		float t = RaySphereIntersectNearest(world_pos, world_dir, vec3(0.0, 0.0, 0.0), planet_radius);\n		if (t < 0.0)\n		{\n		    // Todo: Blend\n			vec3 sun_luminance = vec3(1000000.0);\n			return sun_luminance;\n		}\n	}\n	return vec3(0);\n}\nlayout(binding = 1000) uniform texture2D transmittance_texture;\nlayout(binding = 3000) uniform sampler transmittance_sampler;\nlayout(binding = 2000, rgba32f) uniform image2D multi_scatt_texture;\n\nlayout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;\n\nstruct SingleScatteringResult\n{\n	vec3 luminance;\n	vec3 multi_scat_factor;\n};\n\nSingleScatteringResult IntegrateScatteredLuminance(\n    in vec2 pix_pos, in vec3 world_pos, in vec3 world_dir, in vec3 sun_dir,\n    in AtmosphereParameters atmosphere, in float sample_count, in float t_max_max)\n{\n    SingleScatteringResult result;\n\n    vec3 planet0 = vec3(0.0, 0.0, 0.0);\n    float t_bottom = RaySphereIntersectNearest(world_pos, world_dir, planet0, atmosphere.bottom_radius);\n    float t_top = RaySphereIntersectNearest(world_pos, world_dir, planet0, atmosphere.top_radius);\n    float t_max = 0.0;\n    if (t_bottom < 0.0)\n    {\n        if (t_top < 0.0f)\n        {\n            // No intersect\n            t_max = 0.0f;\n            return result;\n        }\n        else\n        {\n            t_max = t_top;\n        }\n    }\n    else\n    {\n        if (t_top > 0.0f)\n        {\n            t_max = min(t_top, t_bottom);\n        }\n    }\n\n    t_max = min(t_max, t_max_max);\n\n    // Phase functions\n    float uniform_phase = 1.0 / (4.0 * PI);\n\n    // Placeholder\n    vec3 global_l = vec3(1.0);\n\n    // Ray march\n    vec3 luminance = vec3(0.0);\n    vec3 multi_scat_factor = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    float dt = t_max / sample_count;\n    float t = 0.0;\n    float t_prev = 0.0;\n    for (float s = 0.0f; s < sample_count; s += 1.0)\n    {\n        t = dt * s;\n        vec3 p = world_pos + t * world_dir;\n        float p_height = length(p);\n        vec3 up_vector = p / p_height;\n\n        // Sample medium\n        MediumSampleResult medium = SampleMedium(p, atmosphere);\n        vec3 sample_optical_depth = medium.extinction * dt;\n        vec3 sample_transmittance = exp(-sample_optical_depth);\n\n        // Transmittance\n        float sun_zenith_cos_angle = dot(sun_dir, up_vector);\n        vec2 uv;\n        LutTransmittanceParamsToUv(atmosphere, p_height, sun_zenith_cos_angle, uv);\n        vec3 transmittance = textureLod(sampler2D(transmittance_texture, transmittance_sampler), uv, 0.0).rgb;\n\n        // Earth shadow\n        float t_earth = RaySphereIntersectNearest(p, sun_dir, planet0 + 0.01 * up_vector, atmosphere.bottom_radius);\n        float earth_shadow = t_earth >= 0.0 ? 0.0 : 1.0;\n\n        // Todo: Sample shadowmap\n        float shadow = 1.0;\n\n        vec3 phase_times_scattering = medium.scattering * uniform_phase;\n        luminance += global_l * (earth_shadow * shadow * transmittance * phase_times_scattering) * dt;\n        multi_scat_factor += throughput * medium.scattering * 1 * dt;\n        throughput *= sample_transmittance;\n\n        t_prev = t;\n    }\n    result.luminance = luminance;\n    result.multi_scat_factor = multi_scat_factor;\n    return result;\n}\n\nvoid main() {\n    vec3 thread_pos = vec3(gl_GlobalInvocationID);\n	vec2 pix_pos = thread_pos.xy + 0.5;\n	vec2 uv = (pix_pos) / vec2(MULTI_SCATTERING_TEXTURE_SIZE);\n	uv = vec2(FromSubUvsToUnit(uv.x, MULTI_SCATTERING_TEXTURE_SIZE), FromSubUvsToUnit(uv.y, MULTI_SCATTERING_TEXTURE_SIZE));\n\n    AtmosphereParameters atmosphere = GetAtmosphereParameters();\n\n    float cos_sun_zenith_angle = uv.x * 2.0 - 1.0;\n    vec3 sun_dir = vec3(sqrt(saturate(1.0 - cos_sun_zenith_angle * cos_sun_zenith_angle)), cos_sun_zenith_angle, 0.0);\n    float PLANET_RADIUS_OFFSET = 0.01;\n    float view_height = atmosphere.bottom_radius + saturate(uv.y + PLANET_RADIUS_OFFSET) * (atmosphere.top_radius - atmosphere.bottom_radius - PLANET_RADIUS_OFFSET);\n\n    vec3 world_pos = vec3(0.0, view_height, 0.0);\n    vec3 world_dir = vec3(0.0, 1.0, 0.0);\n    float sample_count = 20.0;\n    float t_max_max = 9000000;\n\n    vec3 in_scattered_luminance = vec3(0.0);\n    vec3 multi_scat_factor = vec3(0.0);\n    float sphere_solid_angle = 4.0 * PI;\n    float isotropic_phase = 1.0 / sphere_solid_angle;\n    float SAMPLECOUNT = 16.0;\n    float SQRTSAMPLECOUNT = 4.0;\n    for (float k = 0.0; k < SAMPLECOUNT; ++k) {\n        float i = 0.5 + float(k / SQRTSAMPLECOUNT);\n        float j = 0.5 + float(k - float((k / SQRTSAMPLECOUNT) * SQRTSAMPLECOUNT));\n        float rand_a = i / SQRTSAMPLECOUNT;\n        float rand_b = j / SQRTSAMPLECOUNT;\n        float theta = 2.0 * PI * rand_a;\n        float phi = acos(1.0 - 2.0 * rand_b);\n        float cos_phi = cos(phi);\n        float sin_phi = sin(phi);\n        float cos_theta = cos(theta);\n        float sin_theta = sin(theta);\n        world_dir.x = sin_theta * sin_phi;\n        world_dir.y = cos_phi;\n        world_dir.z = cos_theta * sin_phi;\n\n        SingleScatteringResult result = IntegrateScatteredLuminance(pix_pos, world_pos, world_dir, sun_dir, atmosphere, sample_count, t_max_max);\n        multi_scat_factor += result.multi_scat_factor * sphere_solid_angle / SAMPLECOUNT;\n        in_scattered_luminance += result.luminance * sphere_solid_angle / SAMPLECOUNT;\n    }\n\n    in_scattered_luminance *= isotropic_phase;\n    multi_scat_factor *= isotropic_phase;\n    vec3 multi_scat_factor_sqr = multi_scat_factor * multi_scat_factor;\n    vec3 luminance = in_scattered_luminance * (1.0 + multi_scat_factor + multi_scat_factor_sqr + multi_scat_factor * multi_scat_factor_sqr + multi_scat_factor_sqr * multi_scat_factor_sqr);\n    imageStore(multi_scatt_texture, ivec2(thread_pos.xy), vec4(luminance, 1.0));\n}";
const char ATMOSPHERE_COMPUTE_TRANSMITTANCE_FS_DATA[] = "#version 450\n#extension GL_ARB_separate_shader_objects : enable\n\nuint TRANSMITTANCE_TEXTURE_WIDTH = 64;\nuint TRANSMITTANCE_TEXTURE_HEIGHT = 16;\n\nuint MULTI_SCATTERING_TEXTURE_SIZE = 32;\n\n#define PI 3.1415926535897932384626433832795\n\n#define saturate(x)        clamp(x, 0.0, 1.0)\n\nlayout(std140, set = 0, binding = 0) uniform AtmosphereCB {\n    mat4 sky_inv_view_proj_mat;\n    vec4 resolution;\n    vec4 rayleigh_scattering;\n    vec4 mie_scattering;\n    vec4 mie_extinction;\n    vec4 mie_absorption;\n    vec4 absorption_extinction;\n    vec4 ground_albedo;\n    vec4 sun_direction;\n    vec4 view_direction;\n    vec4 view_position;\n    float bottom_radius;\n    float top_radius;\n    float rayleigh_density_exp_scale;\n    float mie_density_exp_scale;\n    float mie_phase_g;\n    float absorption_density0_layer_width;\n    float absorption_density0_constant_term;\n    float absorption_density0_linear_term;\n    float absorption_density1_constant_term;\n    float absorption_density1_linear_term;\n} atmosphere_cb;\n\nstruct AtmosphereParameters {\n    float bottom_radius;\n    float top_radius;\n\n    float rayleigh_density_exp_scale;\n    vec3 rayleigh_scattering;\n\n    float mie_density_exp_scale;\n    vec3 mie_scattering;\n    vec3 mie_extinction;\n    vec3 mie_absorption;\n    float mie_phase_g;\n\n    float absorption_density0_layer_width;\n    float absorption_density0_constant_term;\n    float absorption_density0_linear_term;\n    float absorption_density1_constant_term;\n    float absorption_density1_linear_term;\n    vec3 absorption_extinction;\n\n    vec3 ground_albedo;\n\n    vec3 sun_direction;\n    vec3 view_direction;\n    vec3 view_position;\n\n    vec2 resolution;\n    mat4 sky_inv_view_proj_mat;\n};\n\nAtmosphereParameters GetAtmosphereParameters()\n{\n    AtmosphereParameters atmosphere_parameters;\n    atmosphere_parameters.bottom_radius = atmosphere_cb.bottom_radius;\n    atmosphere_parameters.top_radius = atmosphere_cb.top_radius;\n\n    atmosphere_parameters.rayleigh_density_exp_scale = atmosphere_cb.rayleigh_density_exp_scale;\n    atmosphere_parameters.rayleigh_scattering = atmosphere_cb.rayleigh_scattering.xyz;\n\n    atmosphere_parameters.mie_density_exp_scale = atmosphere_cb.mie_density_exp_scale;\n    atmosphere_parameters.mie_scattering = atmosphere_cb.mie_scattering.xyz;\n    atmosphere_parameters.mie_extinction = atmosphere_cb.mie_extinction.xyz;\n    atmosphere_parameters.mie_absorption = atmosphere_cb.mie_absorption.xyz;\n    atmosphere_parameters.mie_phase_g = atmosphere_cb.mie_phase_g;\n\n    atmosphere_parameters.absorption_density0_layer_width = atmosphere_cb.absorption_density0_layer_width;\n    atmosphere_parameters.absorption_density0_constant_term = atmosphere_cb.absorption_density0_constant_term;\n    atmosphere_parameters.absorption_density0_linear_term = atmosphere_cb.absorption_density0_linear_term;\n    atmosphere_parameters.absorption_density1_constant_term = atmosphere_cb.absorption_density1_constant_term;\n    atmosphere_parameters.absorption_density1_linear_term = atmosphere_cb.absorption_density1_linear_term;\n    atmosphere_parameters.absorption_extinction = atmosphere_cb.absorption_extinction.xyz;\n\n    atmosphere_parameters.ground_albedo = atmosphere_cb.ground_albedo.xyz;\n\n    atmosphere_parameters.sun_direction = atmosphere_cb.sun_direction.xyz;\n    atmosphere_parameters.view_direction = atmosphere_cb.view_direction.xyz;\n    atmosphere_parameters.view_position = atmosphere_cb.view_position.xyz;\n\n    atmosphere_parameters.resolution = atmosphere_cb.resolution.xy;\n    atmosphere_parameters.sky_inv_view_proj_mat = atmosphere_cb.sky_inv_view_proj_mat;\n\n    return atmosphere_parameters;\n}\n\nfloat RaySphereIntersectNearest(vec3 r0, vec3 rd, vec3 s0, float sr)\n{\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float delta = b * b - 4.0*a*c;\n    if (delta < 0.0 || a == 0.0)\n    {\n        return -1.0;\n    }\n    float sol0 = (-b - sqrt(delta)) / (2.0*a);\n    float sol1 = (-b + sqrt(delta)) / (2.0*a);\n    if (sol0 < 0.0 && sol1 < 0.0)\n    {\n        return -1.0;\n    }\n    if (sol0 < 0.0)\n    {\n        return max(0.0, sol1);\n    }\n    else if (sol1 < 0.0)\n    {\n        return max(0.0, sol0);\n    }\n    return max(0.0, min(sol0, sol1));\n}\n\nstruct MediumSampleResult\n{\n    vec3 scattering;\n    vec3 absorption;\n    vec3 extinction;\n\n    vec3 scattering_mie;\n    vec3 absorption_mie;\n    vec3 extinction_mie;\n\n    vec3 scattering_ray;\n    vec3 absorption_ray;\n    vec3 extinction_ray;\n\n    vec3 scattering_ozo;\n    vec3 absorption_ozo;\n    vec3 extinction_ozo;\n\n    vec3 albedo;\n};\n\nvec3 GetAlbedo(vec3 scattering, vec3 extinction)\n{\n    return scattering / max(vec3(0.001), extinction);\n}\n\nMediumSampleResult SampleMedium(in vec3 world_pos, in AtmosphereParameters atmosphere)\n{\n    float view_height = length(world_pos) - atmosphere.bottom_radius;\n\n    float density_mie = exp(atmosphere.mie_density_exp_scale * view_height);\n    float density_ray = exp(atmosphere.rayleigh_density_exp_scale * view_height);\n    float density_ozo = saturate(view_height < atmosphere.absorption_density0_layer_width ?\n    atmosphere.absorption_density0_linear_term * view_height + atmosphere.absorption_density0_constant_term :\n    atmosphere.absorption_density1_linear_term * view_height + atmosphere.absorption_density1_constant_term);\n\n    MediumSampleResult s;\n\n    s.scattering_mie = density_mie * atmosphere.mie_scattering;\n    s.absorption_mie = density_mie * atmosphere.mie_absorption;\n    s.extinction_mie = density_mie * atmosphere.mie_extinction;\n\n    s.scattering_ray = density_ray * atmosphere.rayleigh_scattering;\n    s.absorption_ray = vec3(0.0);\n    s.extinction_ray = s.scattering_ray + s.absorption_ray;\n\n    s.scattering_ozo = vec3(0.0);\n    s.absorption_ozo = density_ozo * atmosphere.absorption_extinction;\n    s.extinction_ozo = s.scattering_ozo + s.absorption_ozo;\n\n    s.scattering = s.scattering_mie + s.scattering_ray + s.scattering_ozo;\n    s.absorption = s.absorption_mie + s.absorption_ray + s.absorption_ozo;\n    s.extinction = s.extinction_mie + s.extinction_ray + s.extinction_ozo;\n    s.albedo = GetAlbedo(s.scattering, s.extinction);\n\n    return s;\n}\n\nfloat RayleighPhase(float cos_theta)\n{\n	float factor = 3.0 / (16.0 * PI);\n	return factor * (1.0 + cos_theta * cos_theta);\n}\n\nfloat MiePhase(float g, float cos_theta)\n{\n	float numer = 1.0f - g * g;\n	float denom = 1.0f + g * g + 2.0f * g * cos_theta;\n	return numer / (4.0 * PI * denom * sqrt(denom));\n}\n\nfloat FromUnitToSubUvs(float u, float resolution) { return (u + 0.5 / resolution) * (resolution / (resolution + 1.0)); }\nfloat FromSubUvsToUnit(float u, float resolution) { return (u - 0.5 / resolution) * (resolution / (resolution - 1.0)); }\n\nvoid UvToLutTransmittanceParams(AtmosphereParameters atmosphere, out float view_height, out float view_zenith_cos_angle, in vec2 uv)\n{\n    float x_mu = uv.x;\n    float x_r = uv.y;\n\n    float H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);\n    float rho = H * x_r;\n    view_height = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);\n\n    float d_min = atmosphere.top_radius - view_height;\n    float d_max = rho + H;\n    float d = d_min + x_mu * (d_max - d_min);\n    view_zenith_cos_angle = d == 0.0 ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * view_height * d);\n    view_zenith_cos_angle = clamp(view_zenith_cos_angle, -1.0, 1.0);\n}\n\nvoid LutTransmittanceParamsToUv(AtmosphereParameters atmosphere, in float view_height, in float view_zenith_cos_angle, out vec2 uv)\n{\n	float H = sqrt(max(0.0, atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius));\n	float rho = sqrt(max(0.0, view_height * view_height - atmosphere.bottom_radius * atmosphere.bottom_radius));\n\n	float discriminant = view_height * view_height * (view_zenith_cos_angle * view_zenith_cos_angle - 1.0) + atmosphere.top_radius * atmosphere.top_radius;\n	float d = max(0.0, (-view_height * view_zenith_cos_angle + sqrt(discriminant)));\n\n	float d_min = atmosphere.top_radius - view_height;\n	float d_max = rho + H;\n	float x_mu = (d - d_min) / (d_max - d_min);\n	float x_r = rho / H;\n\n	uv = vec2(x_mu, x_r);\n}\n\nvec3 GetSunLuminance(vec3 world_pos, vec3 world_dir, vec3 sun_dir, float planet_radius) {\n	if (dot(world_dir, sun_dir) > cos(0.5 * 0.505 * 3.14159 / 180.0))\n	{\n		float t = RaySphereIntersectNearest(world_pos, world_dir, vec3(0.0, 0.0, 0.0), planet_radius);\n		if (t < 0.0)\n		{\n		    // Todo: Blend\n			vec3 sun_luminance = vec3(1000000.0);\n			return sun_luminance;\n		}\n	}\n	return vec3(0);\n}\nlayout(location = 0) out vec4 out_color;\n\nstruct SingleScatteringResult\n{\n    vec3 optical_depth;\n};\n\nSingleScatteringResult IntegrateScatteredLuminance(\n    in vec2 pix_pos, in vec3 world_pos, in vec3 world_dir,\n    in AtmosphereParameters atmosphere, in float sample_count, in float t_max_max)\n{\n    SingleScatteringResult result;\n\n    vec3 planet0 = vec3(0.0, 0.0, 0.0);\n    float t_bottom = RaySphereIntersectNearest(world_pos, world_dir, planet0, atmosphere.bottom_radius);\n    float t_top = RaySphereIntersectNearest(world_pos, world_dir, planet0, atmosphere.top_radius);\n    float t_max = 0.0;\n    if (t_bottom < 0.0)\n    {\n        if (t_top < 0.0f)\n        {\n            // No intersect\n            t_max = 0.0f;\n            return result;\n        }\n        else\n        {\n            t_max = t_top;\n        }\n    }\n    else\n    {\n        if (t_top > 0.0f)\n        {\n            t_max = min(t_top, t_bottom);\n        }\n    }\n\n    t_max = min(t_max, t_max_max);\n\n    // Ray march\n    vec3 optical_depth = vec3(0.0);\n    float dt = t_max / sample_count;\n    float t = 0.0;\n    float t_prev = 0.0;\n    for (float s = 0.0f; s < sample_count; s += 1.0)\n    {\n        t = dt * s;\n        vec3 p = world_pos + t * world_dir;\n\n        // Sample medium\n        MediumSampleResult medium = SampleMedium(p, atmosphere);\n        vec3 sample_optical_depth = medium.extinction * dt;\n        optical_depth += sample_optical_depth;\n\n        t_prev = t;\n    }\n    result.optical_depth = optical_depth;\n    return result;\n}\n\nvoid main() {\n    AtmosphereParameters atmosphere = GetAtmosphereParameters();\n\n    vec2 pix_pos = gl_FragCoord.xy;\n    vec2 uv = (pix_pos) / vec2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);\n\n    float view_height;\n    float view_zenith_cos_angle;\n    UvToLutTransmittanceParams(atmosphere, view_height, view_zenith_cos_angle, uv);\n\n    vec3 world_pos = vec3(0.0, view_height, 0.0);\n    vec3 world_dir = vec3(sqrt(1.0 - view_zenith_cos_angle * view_zenith_cos_angle), view_zenith_cos_angle, 0.0);\n    float sample_count = 40.0;\n    float t_max_max = 9000000;\n    vec3 transmittance = exp(-IntegrateScatteredLuminance(pix_pos, world_pos, world_dir, atmosphere, sample_count, t_max_max).optical_depth);\n\n    out_color = vec4(transmittance, 1.0);\n}";
const char ATMOSPHERE_RAY_MARCHING_FS_DATA[] = "#version 450\n#extension GL_ARB_separate_shader_objects : enable\n\nuint TRANSMITTANCE_TEXTURE_WIDTH = 64;\nuint TRANSMITTANCE_TEXTURE_HEIGHT = 16;\n\nuint MULTI_SCATTERING_TEXTURE_SIZE = 32;\n\n#define PI 3.1415926535897932384626433832795\n\n#define saturate(x)        clamp(x, 0.0, 1.0)\n\nlayout(std140, set = 0, binding = 0) uniform AtmosphereCB {\n    mat4 sky_inv_view_proj_mat;\n    vec4 resolution;\n    vec4 rayleigh_scattering;\n    vec4 mie_scattering;\n    vec4 mie_extinction;\n    vec4 mie_absorption;\n    vec4 absorption_extinction;\n    vec4 ground_albedo;\n    vec4 sun_direction;\n    vec4 view_direction;\n    vec4 view_position;\n    float bottom_radius;\n    float top_radius;\n    float rayleigh_density_exp_scale;\n    float mie_density_exp_scale;\n    float mie_phase_g;\n    float absorption_density0_layer_width;\n    float absorption_density0_constant_term;\n    float absorption_density0_linear_term;\n    float absorption_density1_constant_term;\n    float absorption_density1_linear_term;\n} atmosphere_cb;\n\nstruct AtmosphereParameters {\n    float bottom_radius;\n    float top_radius;\n\n    float rayleigh_density_exp_scale;\n    vec3 rayleigh_scattering;\n\n    float mie_density_exp_scale;\n    vec3 mie_scattering;\n    vec3 mie_extinction;\n    vec3 mie_absorption;\n    float mie_phase_g;\n\n    float absorption_density0_layer_width;\n    float absorption_density0_constant_term;\n    float absorption_density0_linear_term;\n    float absorption_density1_constant_term;\n    float absorption_density1_linear_term;\n    vec3 absorption_extinction;\n\n    vec3 ground_albedo;\n\n    vec3 sun_direction;\n    vec3 view_direction;\n    vec3 view_position;\n\n    vec2 resolution;\n    mat4 sky_inv_view_proj_mat;\n};\n\nAtmosphereParameters GetAtmosphereParameters()\n{\n    AtmosphereParameters atmosphere_parameters;\n    atmosphere_parameters.bottom_radius = atmosphere_cb.bottom_radius;\n    atmosphere_parameters.top_radius = atmosphere_cb.top_radius;\n\n    atmosphere_parameters.rayleigh_density_exp_scale = atmosphere_cb.rayleigh_density_exp_scale;\n    atmosphere_parameters.rayleigh_scattering = atmosphere_cb.rayleigh_scattering.xyz;\n\n    atmosphere_parameters.mie_density_exp_scale = atmosphere_cb.mie_density_exp_scale;\n    atmosphere_parameters.mie_scattering = atmosphere_cb.mie_scattering.xyz;\n    atmosphere_parameters.mie_extinction = atmosphere_cb.mie_extinction.xyz;\n    atmosphere_parameters.mie_absorption = atmosphere_cb.mie_absorption.xyz;\n    atmosphere_parameters.mie_phase_g = atmosphere_cb.mie_phase_g;\n\n    atmosphere_parameters.absorption_density0_layer_width = atmosphere_cb.absorption_density0_layer_width;\n    atmosphere_parameters.absorption_density0_constant_term = atmosphere_cb.absorption_density0_constant_term;\n    atmosphere_parameters.absorption_density0_linear_term = atmosphere_cb.absorption_density0_linear_term;\n    atmosphere_parameters.absorption_density1_constant_term = atmosphere_cb.absorption_density1_constant_term;\n    atmosphere_parameters.absorption_density1_linear_term = atmosphere_cb.absorption_density1_linear_term;\n    atmosphere_parameters.absorption_extinction = atmosphere_cb.absorption_extinction.xyz;\n\n    atmosphere_parameters.ground_albedo = atmosphere_cb.ground_albedo.xyz;\n\n    atmosphere_parameters.sun_direction = atmosphere_cb.sun_direction.xyz;\n    atmosphere_parameters.view_direction = atmosphere_cb.view_direction.xyz;\n    atmosphere_parameters.view_position = atmosphere_cb.view_position.xyz;\n\n    atmosphere_parameters.resolution = atmosphere_cb.resolution.xy;\n    atmosphere_parameters.sky_inv_view_proj_mat = atmosphere_cb.sky_inv_view_proj_mat;\n\n    return atmosphere_parameters;\n}\n\nfloat RaySphereIntersectNearest(vec3 r0, vec3 rd, vec3 s0, float sr)\n{\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float delta = b * b - 4.0*a*c;\n    if (delta < 0.0 || a == 0.0)\n    {\n        return -1.0;\n    }\n    float sol0 = (-b - sqrt(delta)) / (2.0*a);\n    float sol1 = (-b + sqrt(delta)) / (2.0*a);\n    if (sol0 < 0.0 && sol1 < 0.0)\n    {\n        return -1.0;\n    }\n    if (sol0 < 0.0)\n    {\n        return max(0.0, sol1);\n    }\n    else if (sol1 < 0.0)\n    {\n        return max(0.0, sol0);\n    }\n    return max(0.0, min(sol0, sol1));\n}\n\nstruct MediumSampleResult\n{\n    vec3 scattering;\n    vec3 absorption;\n    vec3 extinction;\n\n    vec3 scattering_mie;\n    vec3 absorption_mie;\n    vec3 extinction_mie;\n\n    vec3 scattering_ray;\n    vec3 absorption_ray;\n    vec3 extinction_ray;\n\n    vec3 scattering_ozo;\n    vec3 absorption_ozo;\n    vec3 extinction_ozo;\n\n    vec3 albedo;\n};\n\nvec3 GetAlbedo(vec3 scattering, vec3 extinction)\n{\n    return scattering / max(vec3(0.001), extinction);\n}\n\nMediumSampleResult SampleMedium(in vec3 world_pos, in AtmosphereParameters atmosphere)\n{\n    float view_height = length(world_pos) - atmosphere.bottom_radius;\n\n    float density_mie = exp(atmosphere.mie_density_exp_scale * view_height);\n    float density_ray = exp(atmosphere.rayleigh_density_exp_scale * view_height);\n    float density_ozo = saturate(view_height < atmosphere.absorption_density0_layer_width ?\n    atmosphere.absorption_density0_linear_term * view_height + atmosphere.absorption_density0_constant_term :\n    atmosphere.absorption_density1_linear_term * view_height + atmosphere.absorption_density1_constant_term);\n\n    MediumSampleResult s;\n\n    s.scattering_mie = density_mie * atmosphere.mie_scattering;\n    s.absorption_mie = density_mie * atmosphere.mie_absorption;\n    s.extinction_mie = density_mie * atmosphere.mie_extinction;\n\n    s.scattering_ray = density_ray * atmosphere.rayleigh_scattering;\n    s.absorption_ray = vec3(0.0);\n    s.extinction_ray = s.scattering_ray + s.absorption_ray;\n\n    s.scattering_ozo = vec3(0.0);\n    s.absorption_ozo = density_ozo * atmosphere.absorption_extinction;\n    s.extinction_ozo = s.scattering_ozo + s.absorption_ozo;\n\n    s.scattering = s.scattering_mie + s.scattering_ray + s.scattering_ozo;\n    s.absorption = s.absorption_mie + s.absorption_ray + s.absorption_ozo;\n    s.extinction = s.extinction_mie + s.extinction_ray + s.extinction_ozo;\n    s.albedo = GetAlbedo(s.scattering, s.extinction);\n\n    return s;\n}\n\nfloat RayleighPhase(float cos_theta)\n{\n	float factor = 3.0 / (16.0 * PI);\n	return factor * (1.0 + cos_theta * cos_theta);\n}\n\nfloat MiePhase(float g, float cos_theta)\n{\n	float numer = 1.0f - g * g;\n	float denom = 1.0f + g * g + 2.0f * g * cos_theta;\n	return numer / (4.0 * PI * denom * sqrt(denom));\n}\n\nfloat FromUnitToSubUvs(float u, float resolution) { return (u + 0.5 / resolution) * (resolution / (resolution + 1.0)); }\nfloat FromSubUvsToUnit(float u, float resolution) { return (u - 0.5 / resolution) * (resolution / (resolution - 1.0)); }\n\nvoid UvToLutTransmittanceParams(AtmosphereParameters atmosphere, out float view_height, out float view_zenith_cos_angle, in vec2 uv)\n{\n    float x_mu = uv.x;\n    float x_r = uv.y;\n\n    float H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);\n    float rho = H * x_r;\n    view_height = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);\n\n    float d_min = atmosphere.top_radius - view_height;\n    float d_max = rho + H;\n    float d = d_min + x_mu * (d_max - d_min);\n    view_zenith_cos_angle = d == 0.0 ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * view_height * d);\n    view_zenith_cos_angle = clamp(view_zenith_cos_angle, -1.0, 1.0);\n}\n\nvoid LutTransmittanceParamsToUv(AtmosphereParameters atmosphere, in float view_height, in float view_zenith_cos_angle, out vec2 uv)\n{\n	float H = sqrt(max(0.0, atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius));\n	float rho = sqrt(max(0.0, view_height * view_height - atmosphere.bottom_radius * atmosphere.bottom_radius));\n\n	float discriminant = view_height * view_height * (view_zenith_cos_angle * view_zenith_cos_angle - 1.0) + atmosphere.top_radius * atmosphere.top_radius;\n	float d = max(0.0, (-view_height * view_zenith_cos_angle + sqrt(discriminant)));\n\n	float d_min = atmosphere.top_radius - view_height;\n	float d_max = rho + H;\n	float x_mu = (d - d_min) / (d_max - d_min);\n	float x_r = rho / H;\n\n	uv = vec2(x_mu, x_r);\n}\n\nvec3 GetSunLuminance(vec3 world_pos, vec3 world_dir, vec3 sun_dir, float planet_radius) {\n	if (dot(world_dir, sun_dir) > cos(0.5 * 0.505 * 3.14159 / 180.0))\n	{\n		float t = RaySphereIntersectNearest(world_pos, world_dir, vec3(0.0, 0.0, 0.0), planet_radius);\n		if (t < 0.0)\n		{\n		    // Todo: Blend\n			vec3 sun_luminance = vec3(1000000.0);\n			return sun_luminance;\n		}\n	}\n	return vec3(0);\n}\nlayout(binding = 1000) uniform texture2D transmittance_texture;\nlayout(binding = 1001) uniform texture2D multi_scatt_texture;\nlayout(binding = 1002) uniform texture2D depth_texture;\nlayout(binding = 3000) uniform sampler default_sampler;\n\nlayout(location = 0) out vec4 out_color;\n\nvec3 GetTransmittance(AtmosphereParameters atmosphere, vec3 world_pos, float view_zenith_cos_angle) {\n    float view_height = length(world_pos);\n    vec2 uv;\n    LutTransmittanceParamsToUv(atmosphere, view_height, view_zenith_cos_angle, uv);\n    vec3 transmittance = textureLod(sampler2D(transmittance_texture, default_sampler), uv, 0.0).rgb;\n    return transmittance;\n}\n\nvec3 GetMultipleScattering(AtmosphereParameters atmosphere, vec3 world_pos, float view_zenith_cos_angle) {\n	vec2 uv = vec2(view_zenith_cos_angle * 0.5 + 0.5, (length(world_pos) - atmosphere.bottom_radius) / (atmosphere.top_radius - atmosphere.bottom_radius));\n	uv = vec2(clamp(uv.x, 0.0, 1.0), clamp(uv.y, 0.0, 1.0));\n	uv = vec2(FromUnitToSubUvs(uv.x, MULTI_SCATTERING_TEXTURE_SIZE), FromUnitToSubUvs(uv.y, MULTI_SCATTERING_TEXTURE_SIZE));\n	vec3 multi_scattered_luminance = textureLod(sampler2D(multi_scatt_texture, default_sampler), uv, 0.0).rgb;\n	return multi_scattered_luminance;\n}\n\nstruct SingleScatteringResult\n{\n	vec3 luminance;\n};\n\nSingleScatteringResult IntegrateScatteredLuminance(\n    in vec2 pix_pos, in vec3 world_pos, in vec3 world_dir, in vec3 sun_dir,\n    in AtmosphereParameters atmosphere, in float sample_count, in float t_max_max)\n{\n    SingleScatteringResult result;\n\n    vec3 planet0 = vec3(0.0, 0.0, 0.0);\n    float t_bottom = RaySphereIntersectNearest(world_pos, world_dir, planet0, atmosphere.bottom_radius);\n    float t_top = RaySphereIntersectNearest(world_pos, world_dir, planet0, atmosphere.top_radius);\n    float t_max = 0.0;\n    if (t_bottom < 0.0)\n    {\n        if (t_top < 0.0f)\n        {\n            // No intersect\n            t_max = 0.0f;\n            return result;\n        }\n        else\n        {\n            t_max = t_top;\n        }\n    }\n    else\n    {\n        if (t_top > 0.0f)\n        {\n            t_max = min(t_top, t_bottom);\n        }\n    }\n\n    t_max = min(t_max, t_max_max);\n\n    // Phase functions\n	vec3 wi = sun_dir;\n	vec3 wo = world_dir;\n	float cos_theta = dot(wi, wo);\n	float mie_phase_value = MiePhase(atmosphere.mie_phase_g, -cos_theta);\n	float rayleigh_phase_value = RayleighPhase(cos_theta);\n\n    // Placeholder\n    vec3 global_l = vec3(1.0);\n\n    // Ray march\n    vec3 luminance = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    float dt = t_max / sample_count;\n    float t = 0.0;\n    float t_prev = 0.0;\n    for (float s = 0.0f; s < sample_count; s += 1.0)\n    {\n        t = dt * s;\n        vec3 p = world_pos + t * world_dir;\n        float p_height = length(p);\n        vec3 up_vector = p / p_height;\n        float sun_zenith_cos_angle = dot(sun_dir, up_vector);\n\n        // Sample medium\n        MediumSampleResult medium = SampleMedium(p, atmosphere);\n        vec3 sample_optical_depth = medium.extinction * dt;\n        vec3 sample_transmittance = exp(-sample_optical_depth);\n\n        // Transmittance\n        vec3 transmittance = GetTransmittance(atmosphere, p, sun_zenith_cos_angle);\n\n        // Multi scatt\n        vec3 multi_scattered_luminance = GetMultipleScattering(atmosphere, p, sun_zenith_cos_angle);\n\n        // Earth shadow\n        float t_earth = RaySphereIntersectNearest(p, sun_dir, planet0 + 0.01 * up_vector, atmosphere.bottom_radius);\n        float earth_shadow = t_earth >= 0.0 ? 0.0 : 1.0;\n\n        // Todo: Sample shadowmap\n        float shadow = 1.0;\n\n        vec3 phase_times_scattering = medium.scattering_mie * mie_phase_value + medium.scattering_ray * rayleigh_phase_value;\n        luminance += global_l * (earth_shadow * shadow * transmittance * phase_times_scattering + multi_scattered_luminance * medium.scattering) * dt;\n\n        throughput *= sample_transmittance;\n\n        t_prev = t;\n    }\n    result.luminance = luminance;\n    return result;\n}\n\nvoid main() {\n    AtmosphereParameters atmosphere = GetAtmosphereParameters();\n\n    vec2 pix_pos = gl_FragCoord.xy;\n    vec2 uv = pix_pos / atmosphere.resolution;\n	vec3 ndc = vec3((pix_pos / atmosphere.resolution) * vec2(2.0, 2.0) - vec2(1.0, 1.0), 1.0);\n	vec4 target_pos = atmosphere.sky_inv_view_proj_mat * vec4(ndc, 1.0);\n    target_pos = target_pos / target_pos.w;\n\n    vec3 sun_dir = -atmosphere.sun_direction;\n	vec3 world_dir = normalize(target_pos.xyz - atmosphere.view_position);\n	vec3 world_pos = atmosphere.view_position + vec3(0.0, atmosphere.bottom_radius, 0.0);\n    float view_height = length(world_pos);\n\n    vec3 luminance = vec3(0.0);\n\n    float depth_buffer_value = textureLod(sampler2D(depth_texture, default_sampler), uv, 0.0).r;\n    if (depth_buffer_value >= 0.99) {\n        luminance += GetSunLuminance(world_pos, world_dir, sun_dir, atmosphere.bottom_radius);\n    }\n\n    float sample_count = 30.0;\n    float t_max_max = 9000000;\n    SingleScatteringResult result = IntegrateScatteredLuminance(pix_pos, world_pos, world_dir, sun_dir, atmosphere, sample_count, t_max_max);\n    luminance += result.luminance;\n\n	vec3 white_point = vec3(1.08241, 0.96756, 0.95003);\n	float exposure = 10.0;\n	luminance = pow(vec3(1.0) - exp(-luminance / white_point * exposure), vec3(1.0 / 2.2));\n\n    out_color = vec4(luminance, 1.0);\n}";
}
